<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QR Color Harmonizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { background: #0f172a; color: #f8fafc; font-family: sans-serif; }
        .canvas-container { display: flex; gap: 20px; flex-wrap: wrap; justify-content: center; }
        canvas { max-width: 100%; height: auto; border: 1px solid #334155; border-radius: 8px; background: #000; }
        .crash-overlay { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(0,0,0,0.9); color: #ff4444; display: none; 
            padding: 40px; z-index: 9999; font-family: monospace;
        }
        .color-swatch { width: 40px; height: 40px; border-radius: 4px; cursor: pointer; border: 2px solid transparent; }
        .color-swatch.active { border-color: white; transform: scale(1.1); }
    </style>
</head>
<body class="p-4 md:p-8">

    <div id="crashGuard" class="crash-overlay">
        <h1 class="text-3xl font-bold mb-4">⚠️ App Crash Detected</h1>
        <p id="errorMessage" class="mb-2 text-xl"></p>
        <p id="errorLocation" class="text-gray-400"></p>
        <button onclick="location.reload()" class="mt-8 bg-red-600 text-white px-4 py-2 rounded">Restart App</button>
    </div>

    <header class="mb-8 border-b border-slate-700 pb-4">
        <h1 class="text-2xl font-bold text-cyan-400">QR Color Harmonizer</h1>
        <p class="text-slate-400">Upload a QR, pick a base color, and apply color theory instantly.</p>
    </header>

    <main class="grid grid-cols-1 lg:grid-cols-3 gap-8">
        <section class="space-y-6 bg-slate-800 p-6 rounded-xl shadow-xl">
            <div>
                <label class="block mb-2 font-semibold">1. Upload QR Code</label>
                <input type="file" id="imageInput" accept="image/*" class="w-full text-sm text-slate-400 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-cyan-600 file:text-white hover:file:bg-cyan-700">
            </div>

            <div>
                <label class="block mb-2 font-semibold">2. Choose Color Theory</label>
                <select id="theorySelect" class="w-full bg-slate-700 p-2 rounded border border-slate-600">
                    <option value="complementary">Complementary (High Contrast)</option>
                    <option value="analogous">Analogous (Smooth Harmony)</option>
                    <option value="triadic">Triadic (Vibrant Balance)</option>
                    <option value="monochromatic">Monochromatic (Clean)</option>
                </select>
            </div>

            <div>
                <label class="block mb-2 font-semibold">3. Pick Primary Color</label>
                <input type="color" id="primaryColor" value="#00ffff" class="w-full h-12 bg-transparent cursor-pointer">
            </div>

            <div id="suggestionsArea">
                <label class="block mb-2 font-semibold">4. Suggested Harmony</label>
                <div id="swatchGrid" class="flex gap-2"></div>
                <p class="text-xs text-slate-400 mt-2 italic">Based on theory: Dark areas will use Primary, Light areas will use Harmony.</p>
            </div>

            <button id="downloadBtn" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 rounded-lg transition-colors">
                Download Result
            </button>
        </section>

        <section class="lg:col-span-2 space-y-4">
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div class="text-center">
                    <span class="text-xs uppercase tracking-widest text-slate-500 font-bold">Original</span>
                    <canvas id="originalCanvas"></canvas>
                </div>
                <div class="text-center">
                    <span class="text-xs uppercase tracking-widest text-cyan-500 font-bold">Recolored</span>
                    <canvas id="previewCanvas"></canvas>
                </div>
            </div>
        </section>
    </main>

    <script>
        /** * CRASH GUARD: Global Error Handler
         * Catches errors, displays the message, and indicates the line number.
         */
        window.onerror = function(message, source, lineno, colno, error) {
            const guard = document.getElementById('crashGuard');
            document.getElementById('errorMessage').innerText = "Error: " + message;
            document.getElementById('errorLocation').innerText = `Source: ${source} | Line: ${lineno}:${colno}`;
            guard.style.display = 'block';
            return true;
        };

        // State Management
        const state = {
            originalImg: null,
            fileType: 'image/png',
            primaryColor: '#00ffff',
            secondaryColor: '#ffffff',
            theory: 'complementary'
        };

        const canvasOrig = document.getElementById('originalCanvas');
        const canvasPrev = document.getElementById('previewCanvas');
        const ctxOrig = canvasOrig.getContext('2d', { willReadFrequently: true });
        const ctxPrev = canvasPrev.getContext('2d', { willReadFrequently: true });

        // Logic: Color Theory Engine
        function hexToHSL(hex) {
            let r = parseInt(hex.slice(1, 3), 16) / 255;
            let g = parseInt(hex.slice(3, 5), 16) / 255;
            let b = parseInt(hex.slice(5, 7), 16) / 255;
            let max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
            if (max == min) { h = s = 0; } else {
                let d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }
            return { h: h * 360, s: s * 100, l: l * 100 };
        }

        function hslToHex(h, s, l) {
            l /= 100;
            const a = s * Math.min(l, 1 - l) / 100;
            const f = n => {
                const k = (n + h / 30) % 12;
                const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
                return Math.round(255 * color).toString(16).padStart(2, '0');
            };
            return `#${f(0)}${f(8)}${f(4)}`;
        }

        function updateHarmonies() {
            const hsl = hexToHSL(state.primaryColor);
            const grid = document.getElementById('swatchGrid');
            grid.innerHTML = '';
            let colors = [];

            if (state.theory === 'complementary') colors = [hslToHex((hsl.h + 180) % 360, hsl.s, hsl.l)];
            if (state.theory === 'analogous') colors = [hslToHex((hsl.h + 30) % 360, hsl.s, hsl.l), hslToHex((hsl.h - 30) % 360, hsl.s, hsl.l)];
            if (state.theory === 'triadic') colors = [hslToHex((hsl.h + 120) % 360, hsl.s, hsl.l), hslToHex((hsl.h + 240) % 360, hsl.s, hsl.l)];
            if (state.theory === 'monochromatic') colors = [hslToHex(hsl.h, hsl.s, Math.max(0, hsl.l - 30)), hslToHex(hsl.h, hsl.s, Math.min(100, hsl.l + 30))];

            colors.forEach((c, i) => {
                const div = document.createElement('div');
                div.className = `color-swatch ${i === 0 ? 'active' : ''}`;
                div.style.backgroundColor = c;
                div.onclick = () => {
                    document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('active'));
                    div.classList.add('active');
                    state.secondaryColor = c;
                    processImage();
                };
                grid.appendChild(div);
                if (i === 0) state.secondaryColor = c;
            });
            processImage();
        }

        // Logic: Image Processing
        function processImage() {
            if (!state.originalImg) return;

            const w = canvasOrig.width;
            const h = canvasOrig.height;
            canvasPrev.width = w;
            canvasPrev.height = h;

            const imgData = ctxOrig.getImageData(0, 0, w, h);
            const data = imgData.data;
            
            const p = hexToRGB(state.primaryColor);
            const s = hexToRGB(state.secondaryColor);

            for (let i = 0; i < data.length; i += 4) {
                // Average brightness to determine if pixel is "Black" or "White"
                const avg = (data[i] + data[i+1] + data[i+2]) / 3;
                
                // If dark (QR modules), use Primary. If light (Background), use Secondary.
                const target = avg < 128 ? p : s;
                
                data[i]     = target.r;
                data[i + 1] = target.g;
                data[i + 2] = target.b;
            }
            ctxPrev.putImageData(imgData, 0, 0);
        }

        function hexToRGB(hex) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return { r, g, b };
        }

        // Event Listeners
        document.getElementById('imageInput').onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;
            state.fileType = file.type;
            const reader = new FileReader();
            reader.onload = (event) => {
                const img = new Image();
                img.onload = () => {
                    state.originalImg = img;
                    canvasOrig.width = img.width;
                    canvasOrig.height = img.height;
                    ctxOrig.drawImage(img, 0, 0);
                    updateHarmonies();
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        };

        document.getElementById('primaryColor').oninput = (e) => {
            state.primaryColor = e.target.value;
            updateHarmonies();
        };

        document.getElementById('theorySelect').onchange = (e) => {
            state.theory = e.target.value;
            updateHarmonies();
        };

        document.getElementById('downloadBtn').onclick = () => {
            const link = document.createElement('a');
            link.download = `recolored-qr.${state.fileType.split('/')[1]}`;
            link.href = canvasPrev.toDataURL(state.fileType);
            link.click();
        };

    </script>
</body>
</html>
