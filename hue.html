<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ChromaShift V2 - Pro Theory Tool</title>
    <style>
        :root { --bg: #1a1a1a; --sidebar: #252525; --text: #e0e0e0; --accent: #4a90e2; --border: #333; }
        body { font-family: sans-serif; background: var(--bg); color: var(--text); margin: 0; display: flex; height: 100vh; overflow: hidden; }
        #controls { width: 380px; background: var(--sidebar); border-right: 1px solid var(--border); padding: 20px; overflow-y: auto; display: flex; flex-direction: column; gap: 15px; }
        .section { border-bottom: 1px solid var(--border); padding-bottom: 15px; }
        h2 { font-size: 1.1rem; margin: 0; color: var(--accent); display: flex; justify-content: space-between; }
        .drop-zone { border: 2px dashed var(--border); padding: 15px; text-align: center; cursor: pointer; font-size: 0.8rem; }
        .palette-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; margin-top: 10px; }
        .color-swatch { width: 100%; aspect-ratio: 1; border-radius: 4px; border: 1px solid #000; cursor: pointer; position: relative; transition: transform 0.1s; }
        .color-swatch.active { outline: 3px solid var(--accent); outline-offset: 2px; transform: scale(0.9); }
        .btn-group { display: grid; grid-template-columns: 1fr 1fr; gap: 5px; margin-top: 10px; }
        button { background: #333; color: white; border: none; padding: 10px; border-radius: 4px; cursor: pointer; font-size: 0.75rem; }
        button:hover { background: #444; }
        button.active { background: var(--accent); }
        #preview { flex-grow: 1; display: flex; flex-direction: column; padding: 20px; gap: 15px; align-items: center; justify-content: center; background: #111; overflow-y: auto; }
        canvas { max-width: 90%; max-height: 42%; background: #222; box-shadow: 0 5px 15px rgba(0,0,0,0.5); border: 1px solid #333; }
        .label { font-size: 0.65rem; text-transform: uppercase; letter-spacing: 1px; color: #777; margin-bottom: 5px; display: block; }
        #shade-grid { display: grid; grid-template-columns: repeat(10, 1fr); gap: 2px; }
        .slider-label { display: flex; justify-content: space-between; font-size: 0.75rem; margin-top: 10px; }
        input[type="range"] { width: 100%; accent-color: var(--accent); }
    </style>
</head>
<body>

<div id="controls">
    <h2>ChromaShift <span>v2.0</span></h2>
    
    <div class="section">
        <div class="drop-zone" id="drop-zone">DROP IMAGE / LOGO / QR</div>
        <input type="file" id="file-input" hidden accept="image/*">
    </div>

    <div class="section" id="mode-section">
        <label class="slider-label"><span>QR/Logo Mode</span><input type="checkbox" id="qr-mode"></label>
        <p style="font-size: 0.7rem; color: #888;">QR Mode forces 2-color high contrast to keep codes working.</p>
        
        <label class="slider-label"><span>Color Sensitivity</span> <span id="fuzz-val">15</span></label>
        <input type="range" id="fuzz-range" min="1" max="100" value="15">
    </div>

    <div class="section" id="palette-section" style="display:none;">
        <label class="label">Detected Palette</label>
        <div class="palette-grid" id="detected-palette"></div>
    </div>

    <div class="section" id="theory-section" style="display:none;">
        <label class="label">Color Theory Engine</label>
        <div class="btn-group">
            <button onclick="applyTheory('comp')">Complementary</button>
            <button onclick="applyTheory('triad')">Triadic</button>
            <button onclick="applyTheory('analog')">Analogous</button>
            <button onclick="applyTheory('mono')">Monochromatic</button>
        </div>
        <div class="palette-grid" id="suggested-palette"></div>
    </div>

    <div class="section" id="manual-section" style="display:none;">
        <label class="label">Manual Fine-Tune (Shades/Tints)</label>
        <div id="shade-grid"></div>
    </div>

    <button id="download-btn" style="display:none; width: 100%; background: var(--accent); font-weight: bold; padding: 15px; margin-top: auto;">DOWNLOAD PNG</button>
</div>

<div id="preview">
    <div><span class="label">Original Source</span><canvas id="canvas-orig"></canvas></div>
    <div><span class="label">Processed Preview</span><canvas id="canvas-proc"></canvas></div>
</div>

<script>
    const fileInput = document.getElementById('file-input');
    const dropZone = document.getElementById('drop-zone');
    const canvasOrig = document.getElementById('canvas-orig');
    const canvasProc = document.getElementById('canvas-proc');
    const ctxOrig = canvasOrig.getContext('2d', {willReadFrequently: true});
    const ctxProc = canvasProc.getContext('2d');
    const fuzzRange = document.getElementById('fuzz-range');
    const qrToggle = document.getElementById('qr-mode');
    
    let originalImage = null;
    let detectedColors = [];
    let selectedColorIndex = 0;
    let colorMap = new Map(); 

    dropZone.onclick = () => fileInput.click();
    fileInput.onchange = (e) => handleImage(e.target.files[0]);
    fuzzRange.oninput = (e) => { document.getElementById('fuzz-val').innerText = e.target.value; extractPalette(); };
    qrToggle.onchange = () => processImage();

    function handleImage(file) {
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (event) => {
            const img = new Image();
            img.onload = () => {
                originalImage = img;
                setupCanvases(img);
                extractPalette();
                ['palette-section','theory-section','download-btn'].forEach(id => document.getElementById(id).style.display = 'block');
            };
            img.src = event.target.result;
        };
        reader.readAsDataURL(file);
    }

    function setupCanvases(img) {
        const maxDim = 800; 
        let w = img.width, h = img.height;
        if (w > maxDim || h > maxDim) {
            const ratio = Math.min(maxDim/w, maxDim/h);
            w *= ratio; h *= ratio;
        }
        canvasOrig.width = canvasProc.width = w;
        canvasOrig.height = canvasProc.height = h;
        ctxOrig.drawImage(img, 0, 0, w, h);
        ctxProc.drawImage(img, 0, 0, w, h);
    }

    function extractPalette() {
        const data = ctxOrig.getImageData(0, 0, canvasOrig.width, canvasOrig.height).data;
        const counts = {};
        const fuzz = parseInt(fuzzRange.value);

        for (let i = 0; i < data.length; i += 40) {
            if (data[i+3] < 128) continue; 
            // Fuzziness logic: round colors to reduce noise
            const r = Math.round(data[i]/fuzz)*fuzz;
            const g = Math.round(data[i+1]/fuzz)*fuzz;
            const b = Math.round(data[i+2]/fuzz)*fuzz;
            const hex = rgbToHex(Math.min(255,r), Math.min(255,g), Math.min(255,b));
            counts[hex] = (counts[hex] || 0) + 1;
        }
        
        detectedColors = Object.entries(counts)
            .sort((a, b) => b[1] - a[1])
            .slice(0, 12)
            .map(x => x[0]);

        colorMap.clear();
        renderDetectedPalette();
        processImage();
    }

    function renderDetectedPalette() {
        const container = document.getElementById('detected-palette');
        container.innerHTML = '';
        detectedColors.forEach((hex, i) => {
            const div = document.createElement('div');
            div.className = `color-swatch ${i === selectedColorIndex ? 'active' : ''}`;
            div.style.backgroundColor = hex;
            div.onclick = () => { selectedColorIndex = i; renderDetectedPalette(); renderShadeGrid(hex); };
            container.appendChild(div);
        });
        renderShadeGrid(detectedColors[selectedColorIndex]);
    }

    function applyTheory(type) {
        const baseHex = detectedColors[selectedColorIndex];
        const hsl = hexToHsl(baseHex);
        let suggestions = [];
        if (type === 'comp') suggestions = [hslToHex((hsl.h + 180) % 360, hsl.s, hsl.l)];
        if (type === 'triad') suggestions = [hslToHex((hsl.h + 120) % 360, hsl.s, hsl.l), hslToHex((hsl.h + 240) % 360, hsl.s, hsl.l)];
        if (type === 'analog') suggestions = [hslToHex((hsl.h + 30) % 360, hsl.s, hsl.l), hslToHex((hsl.h - 30 + 360) % 360, hsl.s, hsl.l)];
        if (type === 'mono') suggestions = [hslToHex(hsl.h, hsl.s, Math.max(0, hsl.l - 30)), hslToHex(hsl.h, hsl.s, Math.min(100, hsl.l + 30))];

        const container = document.getElementById('suggested-palette');
        container.innerHTML = '';
        suggestions.forEach(hex => {
            const div = document.createElement('div');
            div.className = 'color-swatch';
            div.style.backgroundColor = hex;
            div.onclick = () => updateImageColor(baseHex, hex);
            container.appendChild(div);
        });
    }

    function renderShadeGrid(hex) {
        document.getElementById('manual-section').style.display = 'block';
        const grid = document.getElementById('shade-grid');
        grid.innerHTML = '';
        const hsl = hexToHsl(hex);
        for (let l = 5; l <= 95; l += 10) {
            const newHex = hslToHex(hsl.h, hsl.s, l);
            const div = document.createElement('div');
            div.className = 'color-swatch';
            div.style.backgroundColor = newHex;
            div.onclick = () => updateImageColor(hex, newHex);
            grid.appendChild(div);
        }
    }

    function updateImageColor(oldHex, newHex) {
        colorMap.set(oldHex.toLowerCase(), hexToRgb(newHex));
        processImage();
    }

    function processImage() {
        if (!originalImage) return;
        const imgData = ctxOrig.getImageData(0, 0, canvasOrig.width, canvasOrig.height);
        const data = imgData.data;
        const isQR = qrToggle.checked;
        const fuzz = parseInt(fuzzRange.value);

        // Pre-calculate target colors for QR mode
        const darkTarget = colorMap.get(detectedColors[0]?.toLowerCase()) || hexToRgb(detectedColors[0]);
        const lightTarget = colorMap.get(detectedColors[1]?.toLowerCase()) || hexToRgb(detectedColors[1]);

        for (let i = 0; i < data.length; i += 4) {
            if (data[i+3] === 0) continue;
            const r = data[i], g = data[i+1], b = data[i+2];

            if (isQR) {
                const brightness = (0.299 * r + 0.587 * g + 0.114 * b);
                const target = (brightness < 128) ? darkTarget : lightTarget;
                if(target) { data[i] = target.r; data[i+1] = target.g; data[i+2] = target.b; }
            } else {
                const hex = rgbToHex(Math.round(r/fuzz)*fuzz, Math.round(g/fuzz)*fuzz, Math.round(b/fuzz)*fuzz).toLowerCase();
                const target = colorMap.get(hex);
                if (target) { data[i] = target.r; data[i+1] = target.g; data[i+2] = target.b; }
            }
        }
        ctxProc.putImageData(imgData, 0, 0);
    }

    function rgbToHex(r, g, b) { return "#" + [r, g, b].map(x => Math.max(0, Math.min(255, x)).toString(16).padStart(2, '0')).join(''); }
    function hexToRgb(hex) { const r = parseInt(hex.slice(1,3),16), g = parseInt(hex.slice(3,5),16), b = parseInt(hex.slice(5,7),16); return {r,g,b}; }
    function hexToHsl(hex) {
        let {r, g, b} = hexToRgb(hex);
        r /= 255; g /= 255; b /= 255;
        const max = Math.max(r, g, b), min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;
        if (max === min) h = s = 0;
        else {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            if (max===r) h = (g - b) / d + (g < b ? 6 : 0);
            else if (max===g) h = (b - r) / d + 2;
            else h = (r - g) / d + 4;
            h /= 6;
        }
        return { h: h * 360, s: s * 100, l: l * 100 };
    }
    function hslToHex(h, s, l) {
        l /= 100; const a = s * Math.min(l, 1 - l) / 100;
        const f = n => { const k = (n + h / 30) % 12; const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1); return Math.round(255 * color).toString(16).padStart(2, '0'); };
        return `#${f(0)}${f(8)}${f(4)}`;
    }

    document.getElementById('download-btn').onclick = () => {
        const link = document.createElement('a');
        link.download = 'chromashift-v2.png';
        link.href = canvasProc.toDataURL();
        link.click();
    };
</script>
</body>
</html>
